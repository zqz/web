// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: files.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countFiles = `-- name: CountFiles :one
SELECT COUNT(*) FROM files
`

func (q *Queries) CountFiles(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countFiles)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countFilesByUserID = `-- name: CountFilesByUserID :one
SELECT COUNT(*) FROM files
WHERE user_id = $1
`

func (q *Queries) CountFilesByUserID(ctx context.Context, userID *int32) (int64, error) {
	row := q.db.QueryRow(ctx, countFilesByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createFile = `-- name: CreateFile :one
INSERT INTO files (
    size,
    name,
    alias,
    hash,
    slug,
    content_type,
    user_id,
    private,
    comment,
    bytes_received,
    created_at,
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, NOW(), NOW()
) RETURNING id, size, name, alias, hash, slug, content_type, created_at, updated_at, user_id, private, comment, bytes_received
`

type CreateFileParams struct {
	Size          int32  `db:"size" json:"size"`
	Name          string `db:"name" json:"name"`
	Alias         string `db:"alias" json:"alias"`
	Hash          string `db:"hash" json:"hash"`
	Slug          string `db:"slug" json:"slug"`
	ContentType   string `db:"content_type" json:"content_type"`
	UserID        *int32 `db:"user_id" json:"user_id"`
	Private       bool   `db:"private" json:"private"`
	Comment       string `db:"comment" json:"comment"`
	BytesReceived int32  `db:"bytes_received" json:"bytes_received"`
}

func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (File, error) {
	row := q.db.QueryRow(ctx, createFile,
		arg.Size,
		arg.Name,
		arg.Alias,
		arg.Hash,
		arg.Slug,
		arg.ContentType,
		arg.UserID,
		arg.Private,
		arg.Comment,
		arg.BytesReceived,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Size,
		&i.Name,
		&i.Alias,
		&i.Hash,
		&i.Slug,
		&i.ContentType,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.Private,
		&i.Comment,
		&i.BytesReceived,
	)
	return i, err
}

const deleteFile = `-- name: DeleteFile :exec
DELETE FROM files
WHERE id = $1
`

func (q *Queries) DeleteFile(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteFile, id)
	return err
}

const deleteFilesByUserID = `-- name: DeleteFilesByUserID :exec
DELETE FROM files
WHERE user_id = $1
`

func (q *Queries) DeleteFilesByUserID(ctx context.Context, userID *int32) error {
	_, err := q.db.Exec(ctx, deleteFilesByUserID, userID)
	return err
}

const getFileByHash = `-- name: GetFileByHash :one
SELECT id, size, name, alias, hash, slug, content_type, created_at, updated_at, user_id, private, comment, bytes_received FROM files
WHERE hash = $1 LIMIT 1
`

func (q *Queries) GetFileByHash(ctx context.Context, hash string) (File, error) {
	row := q.db.QueryRow(ctx, getFileByHash, hash)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Size,
		&i.Name,
		&i.Alias,
		&i.Hash,
		&i.Slug,
		&i.ContentType,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.Private,
		&i.Comment,
		&i.BytesReceived,
	)
	return i, err
}

const getFileByID = `-- name: GetFileByID :one
SELECT id, size, name, alias, hash, slug, content_type, created_at, updated_at, user_id, private, comment, bytes_received FROM files
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetFileByID(ctx context.Context, id int32) (File, error) {
	row := q.db.QueryRow(ctx, getFileByID, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Size,
		&i.Name,
		&i.Alias,
		&i.Hash,
		&i.Slug,
		&i.ContentType,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.Private,
		&i.Comment,
		&i.BytesReceived,
	)
	return i, err
}

const getFileBySlug = `-- name: GetFileBySlug :one
SELECT id, size, name, alias, hash, slug, content_type, created_at, updated_at, user_id, private, comment, bytes_received FROM files
WHERE slug = $1 LIMIT 1
`

func (q *Queries) GetFileBySlug(ctx context.Context, slug string) (File, error) {
	row := q.db.QueryRow(ctx, getFileBySlug, slug)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Size,
		&i.Name,
		&i.Alias,
		&i.Hash,
		&i.Slug,
		&i.ContentType,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.Private,
		&i.Comment,
		&i.BytesReceived,
	)
	return i, err
}

const getFileWithThumbnail = `-- name: GetFileWithThumbnail :one
SELECT 
    f.id,
    f.size,
    f.name,
    f.alias,
    f.hash,
    f.slug,
    f.content_type,
    f.user_id,
    f.private,
    f.comment,
    f.created_at,
    f.updated_at,
    t.hash as thumbnail_hash,
    t.width as thumbnail_width,
    t.height as thumbnail_height
FROM files f
LEFT JOIN thumbnails t ON t.file_id = f.id
WHERE f.id = $1
LIMIT 1
`

type GetFileWithThumbnailRow struct {
	ID              int32            `db:"id" json:"id"`
	Size            int32            `db:"size" json:"size"`
	Name            string           `db:"name" json:"name"`
	Alias           string           `db:"alias" json:"alias"`
	Hash            string           `db:"hash" json:"hash"`
	Slug            string           `db:"slug" json:"slug"`
	ContentType     string           `db:"content_type" json:"content_type"`
	UserID          *int32           `db:"user_id" json:"user_id"`
	Private         bool             `db:"private" json:"private"`
	Comment         string           `db:"comment" json:"comment"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	ThumbnailHash   *string          `db:"thumbnail_hash" json:"thumbnail_hash"`
	ThumbnailWidth  *int32           `db:"thumbnail_width" json:"thumbnail_width"`
	ThumbnailHeight *int32           `db:"thumbnail_height" json:"thumbnail_height"`
}

func (q *Queries) GetFileWithThumbnail(ctx context.Context, id int32) (GetFileWithThumbnailRow, error) {
	row := q.db.QueryRow(ctx, getFileWithThumbnail, id)
	var i GetFileWithThumbnailRow
	err := row.Scan(
		&i.ID,
		&i.Size,
		&i.Name,
		&i.Alias,
		&i.Hash,
		&i.Slug,
		&i.ContentType,
		&i.UserID,
		&i.Private,
		&i.Comment,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ThumbnailHash,
		&i.ThumbnailWidth,
		&i.ThumbnailHeight,
	)
	return i, err
}

const getFileWithThumbnailByHash = `-- name: GetFileWithThumbnailByHash :one
SELECT 
    f.id,
    f.size,
    f.name,
    f.alias,
    f.hash,
    f.slug,
    f.content_type,
    f.user_id,
    f.private,
    f.comment,
    f.created_at,
    f.updated_at,
    t.hash as thumbnail_hash,
    t.width as thumbnail_width,
    t.height as thumbnail_height
FROM files f
LEFT JOIN thumbnails t ON t.file_id = f.id
WHERE f.hash = $1
LIMIT 1
`

type GetFileWithThumbnailByHashRow struct {
	ID              int32            `db:"id" json:"id"`
	Size            int32            `db:"size" json:"size"`
	Name            string           `db:"name" json:"name"`
	Alias           string           `db:"alias" json:"alias"`
	Hash            string           `db:"hash" json:"hash"`
	Slug            string           `db:"slug" json:"slug"`
	ContentType     string           `db:"content_type" json:"content_type"`
	UserID          *int32           `db:"user_id" json:"user_id"`
	Private         bool             `db:"private" json:"private"`
	Comment         string           `db:"comment" json:"comment"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	ThumbnailHash   *string          `db:"thumbnail_hash" json:"thumbnail_hash"`
	ThumbnailWidth  *int32           `db:"thumbnail_width" json:"thumbnail_width"`
	ThumbnailHeight *int32           `db:"thumbnail_height" json:"thumbnail_height"`
}

func (q *Queries) GetFileWithThumbnailByHash(ctx context.Context, hash string) (GetFileWithThumbnailByHashRow, error) {
	row := q.db.QueryRow(ctx, getFileWithThumbnailByHash, hash)
	var i GetFileWithThumbnailByHashRow
	err := row.Scan(
		&i.ID,
		&i.Size,
		&i.Name,
		&i.Alias,
		&i.Hash,
		&i.Slug,
		&i.ContentType,
		&i.UserID,
		&i.Private,
		&i.Comment,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ThumbnailHash,
		&i.ThumbnailWidth,
		&i.ThumbnailHeight,
	)
	return i, err
}

const getFileWithThumbnailBySlug = `-- name: GetFileWithThumbnailBySlug :one
SELECT 
    f.id,
    f.size,
    f.name,
    f.alias,
    f.hash,
    f.slug,
    f.content_type,
    f.user_id,
    f.private,
    f.comment,
    f.created_at,
    f.updated_at,
    t.hash as thumbnail_hash,
    t.width as thumbnail_width,
    t.height as thumbnail_height
FROM files f
LEFT JOIN thumbnails t ON t.file_id = f.id
WHERE f.slug = $1
LIMIT 1
`

type GetFileWithThumbnailBySlugRow struct {
	ID              int32            `db:"id" json:"id"`
	Size            int32            `db:"size" json:"size"`
	Name            string           `db:"name" json:"name"`
	Alias           string           `db:"alias" json:"alias"`
	Hash            string           `db:"hash" json:"hash"`
	Slug            string           `db:"slug" json:"slug"`
	ContentType     string           `db:"content_type" json:"content_type"`
	UserID          *int32           `db:"user_id" json:"user_id"`
	Private         bool             `db:"private" json:"private"`
	Comment         string           `db:"comment" json:"comment"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	ThumbnailHash   *string          `db:"thumbnail_hash" json:"thumbnail_hash"`
	ThumbnailWidth  *int32           `db:"thumbnail_width" json:"thumbnail_width"`
	ThumbnailHeight *int32           `db:"thumbnail_height" json:"thumbnail_height"`
}

func (q *Queries) GetFileWithThumbnailBySlug(ctx context.Context, slug string) (GetFileWithThumbnailBySlugRow, error) {
	row := q.db.QueryRow(ctx, getFileWithThumbnailBySlug, slug)
	var i GetFileWithThumbnailBySlugRow
	err := row.Scan(
		&i.ID,
		&i.Size,
		&i.Name,
		&i.Alias,
		&i.Hash,
		&i.Slug,
		&i.ContentType,
		&i.UserID,
		&i.Private,
		&i.Comment,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ThumbnailHash,
		&i.ThumbnailWidth,
		&i.ThumbnailHeight,
	)
	return i, err
}

const listFiles = `-- name: ListFiles :many
SELECT id, size, name, alias, hash, slug, content_type, created_at, updated_at, user_id, private, comment, bytes_received FROM files
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListFilesParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListFiles(ctx context.Context, arg ListFilesParams) ([]File, error) {
	rows, err := q.db.Query(ctx, listFiles, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Size,
			&i.Name,
			&i.Alias,
			&i.Hash,
			&i.Slug,
			&i.ContentType,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.Private,
			&i.Comment,
			&i.BytesReceived,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFilesByUserID = `-- name: ListFilesByUserID :many
SELECT id, size, name, alias, hash, slug, content_type, created_at, updated_at, user_id, private, comment, bytes_received FROM files
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListFilesByUserIDParams struct {
	UserID *int32 `db:"user_id" json:"user_id"`
	Limit  int32  `db:"limit" json:"limit"`
	Offset int32  `db:"offset" json:"offset"`
}

func (q *Queries) ListFilesByUserID(ctx context.Context, arg ListFilesByUserIDParams) ([]File, error) {
	rows, err := q.db.Query(ctx, listFilesByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Size,
			&i.Name,
			&i.Alias,
			&i.Hash,
			&i.Slug,
			&i.ContentType,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.Private,
			&i.Comment,
			&i.BytesReceived,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFilesVisibleToUser = `-- name: ListFilesVisibleToUser :many
SELECT id, size, name, alias, hash, slug, content_type, created_at, updated_at, user_id, private, comment, bytes_received FROM files
WHERE private = false OR user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListFilesVisibleToUserParams struct {
	UserID *int32 `db:"user_id" json:"user_id"`
	Limit  int32  `db:"limit" json:"limit"`
	Offset int32  `db:"offset" json:"offset"`
}

func (q *Queries) ListFilesVisibleToUser(ctx context.Context, arg ListFilesVisibleToUserParams) ([]File, error) {
	rows, err := q.db.Query(ctx, listFilesVisibleToUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Size,
			&i.Name,
			&i.Alias,
			&i.Hash,
			&i.Slug,
			&i.ContentType,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.Private,
			&i.Comment,
			&i.BytesReceived,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFilesWithThumbnails = `-- name: ListFilesWithThumbnails :many
SELECT 
    f.id,
    f.size,
    f.name,
    f.alias,
    f.hash,
    f.slug,
    f.content_type,
    f.user_id,
    f.private,
    f.comment,
    f.created_at,
    f.updated_at,
    t.hash as thumbnail_hash,
    t.width as thumbnail_width,
    t.height as thumbnail_height
FROM files f
LEFT JOIN thumbnails t ON t.file_id = f.id
ORDER BY f.created_at DESC
LIMIT $1 OFFSET $2
`

type ListFilesWithThumbnailsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type ListFilesWithThumbnailsRow struct {
	ID              int32            `db:"id" json:"id"`
	Size            int32            `db:"size" json:"size"`
	Name            string           `db:"name" json:"name"`
	Alias           string           `db:"alias" json:"alias"`
	Hash            string           `db:"hash" json:"hash"`
	Slug            string           `db:"slug" json:"slug"`
	ContentType     string           `db:"content_type" json:"content_type"`
	UserID          *int32           `db:"user_id" json:"user_id"`
	Private         bool             `db:"private" json:"private"`
	Comment         string           `db:"comment" json:"comment"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	ThumbnailHash   *string          `db:"thumbnail_hash" json:"thumbnail_hash"`
	ThumbnailWidth  *int32           `db:"thumbnail_width" json:"thumbnail_width"`
	ThumbnailHeight *int32           `db:"thumbnail_height" json:"thumbnail_height"`
}

func (q *Queries) ListFilesWithThumbnails(ctx context.Context, arg ListFilesWithThumbnailsParams) ([]ListFilesWithThumbnailsRow, error) {
	rows, err := q.db.Query(ctx, listFilesWithThumbnails, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFilesWithThumbnailsRow{}
	for rows.Next() {
		var i ListFilesWithThumbnailsRow
		if err := rows.Scan(
			&i.ID,
			&i.Size,
			&i.Name,
			&i.Alias,
			&i.Hash,
			&i.Slug,
			&i.ContentType,
			&i.UserID,
			&i.Private,
			&i.Comment,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ThumbnailHash,
			&i.ThumbnailWidth,
			&i.ThumbnailHeight,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublicFiles = `-- name: ListPublicFiles :many
SELECT id, size, name, alias, hash, slug, content_type, created_at, updated_at, user_id, private, comment, bytes_received FROM files
WHERE private = false
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListPublicFilesParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListPublicFiles(ctx context.Context, arg ListPublicFilesParams) ([]File, error) {
	rows, err := q.db.Query(ctx, listPublicFiles, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Size,
			&i.Name,
			&i.Alias,
			&i.Hash,
			&i.Slug,
			&i.ContentType,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.Private,
			&i.Comment,
			&i.BytesReceived,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchFiles = `-- name: SearchFiles :many
SELECT id, size, name, alias, hash, slug, content_type, created_at, updated_at, user_id, private, comment, bytes_received FROM files
WHERE (name % $1 OR alias % $1 OR COALESCE(comment, '') % $1)
   OR (POSITION(LOWER($1) IN LOWER(name)) > 0 OR POSITION(LOWER($1) IN LOWER(COALESCE(alias, ''))) > 0 OR POSITION(LOWER($1) IN LOWER(COALESCE(comment, ''))) > 0)
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type SearchFilesParams struct {
	Name   string `db:"name" json:"name"`
	Limit  int32  `db:"limit" json:"limit"`
	Offset int32  `db:"offset" json:"offset"`
}

func (q *Queries) SearchFiles(ctx context.Context, arg SearchFilesParams) ([]File, error) {
	rows, err := q.db.Query(ctx, searchFiles, arg.Name, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Size,
			&i.Name,
			&i.Alias,
			&i.Hash,
			&i.Slug,
			&i.ContentType,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.Private,
			&i.Comment,
			&i.BytesReceived,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchFilesVisibleToUser = `-- name: SearchFilesVisibleToUser :many
SELECT id, size, name, alias, hash, slug, content_type, created_at, updated_at, user_id, private, comment, bytes_received FROM files
WHERE (private = false OR user_id = $1)
  AND ((name % $2 OR alias % $2 OR COALESCE(comment, '') % $2)
   OR (POSITION(LOWER($2) IN LOWER(name)) > 0 OR POSITION(LOWER($2) IN LOWER(COALESCE(alias, ''))) > 0 OR POSITION(LOWER($2) IN LOWER(COALESCE(comment, ''))) > 0))
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type SearchFilesVisibleToUserParams struct {
	UserID *int32 `db:"user_id" json:"user_id"`
	Name   string `db:"name" json:"name"`
	Limit  int32  `db:"limit" json:"limit"`
	Offset int32  `db:"offset" json:"offset"`
}

func (q *Queries) SearchFilesVisibleToUser(ctx context.Context, arg SearchFilesVisibleToUserParams) ([]File, error) {
	rows, err := q.db.Query(ctx, searchFilesVisibleToUser,
		arg.UserID,
		arg.Name,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Size,
			&i.Name,
			&i.Alias,
			&i.Hash,
			&i.Slug,
			&i.ContentType,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.Private,
			&i.Comment,
			&i.BytesReceived,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPublicFiles = `-- name: SearchPublicFiles :many
SELECT id, size, name, alias, hash, slug, content_type, created_at, updated_at, user_id, private, comment, bytes_received FROM files
WHERE private = false
  AND ((name % $1 OR alias % $1 OR COALESCE(comment, '') % $1)
   OR (POSITION(LOWER($1) IN LOWER(name)) > 0 OR POSITION(LOWER($1) IN LOWER(COALESCE(alias, ''))) > 0 OR POSITION(LOWER($1) IN LOWER(COALESCE(comment, ''))) > 0))
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type SearchPublicFilesParams struct {
	Name   string `db:"name" json:"name"`
	Limit  int32  `db:"limit" json:"limit"`
	Offset int32  `db:"offset" json:"offset"`
}

func (q *Queries) SearchPublicFiles(ctx context.Context, arg SearchPublicFilesParams) ([]File, error) {
	rows, err := q.db.Query(ctx, searchPublicFiles, arg.Name, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Size,
			&i.Name,
			&i.Alias,
			&i.Hash,
			&i.Slug,
			&i.ContentType,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.Private,
			&i.Comment,
			&i.BytesReceived,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const totalFileSize = `-- name: TotalFileSize :one
SELECT COALESCE(SUM(size), 0)::bigint FROM files
`

func (q *Queries) TotalFileSize(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, totalFileSize)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const updateFile = `-- name: UpdateFile :one
UPDATE files
SET
    name = COALESCE($1, name),
    alias = COALESCE($2, alias),
    slug = COALESCE($3, slug),
    private = COALESCE($4, private),
    comment = COALESCE($5, comment),
    bytes_received = COALESCE($6, bytes_received),
    updated_at = NOW()
WHERE id = $7
RETURNING id, size, name, alias, hash, slug, content_type, created_at, updated_at, user_id, private, comment, bytes_received
`

type UpdateFileParams struct {
	Name          *string `db:"name" json:"name"`
	Alias         *string `db:"alias" json:"alias"`
	Slug          *string `db:"slug" json:"slug"`
	Private       *bool   `db:"private" json:"private"`
	Comment       *string `db:"comment" json:"comment"`
	BytesReceived *int32  `db:"bytes_received" json:"bytes_received"`
	ID            int32   `db:"id" json:"id"`
}

func (q *Queries) UpdateFile(ctx context.Context, arg UpdateFileParams) (File, error) {
	row := q.db.QueryRow(ctx, updateFile,
		arg.Name,
		arg.Alias,
		arg.Slug,
		arg.Private,
		arg.Comment,
		arg.BytesReceived,
		arg.ID,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Size,
		&i.Name,
		&i.Alias,
		&i.Hash,
		&i.Slug,
		&i.ContentType,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.Private,
		&i.Comment,
		&i.BytesReceived,
	)
	return i, err
}
